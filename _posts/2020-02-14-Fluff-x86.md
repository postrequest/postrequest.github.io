---
title: Fluff x86
tags: [rop,rop chain,exploitation,x86,asm]
published: true
description: Solving fluff by rop emporium
toc: true
---

# Introduction
Fluff is the 5th challenge in the <a href="https://ropemporium.com/">ROP Emproium</a> series.  
This is the approach taken to solve the 32 bit challenge step by step.  
If you would like extra information on Return Oriented Programming (ROP) visit the <a href="https://ropemporium.com/guide.html">ROP Emporium Guide</a>.  

### Challenge description
Sort the useful gadgets from the fluff to construct another write primitive in this challenge.  
You'll have to get creative though, the gadgets aren't straight forward.

# Solution 
The solution will be written in Go using the standard library only.  
Although <a href="https://github.com/Gallopsled/pwntools#readme">pwntools</a> is a quick and easy way to approach this problem, Go can compile
to a statically linked executable for most target systems.  
Since we already know the exploit path, we can focus on creating a ROP chain to obtain a system shell.  

### Assumptions
You have the following software installed:
- <a href="https://golang.org/">Golang</a>
- <a href="https://www.radare.org/">radare2</a>
- <a href="https://cutter.re/">Cutter</a>

# Technical

#### Inspect the binary
##### Check the properties:
<a href="/assets/img/2020-02-14-Fluff-x86/binary-info.png"><img src="/assets/img/2020-02-14-Fluff-x86/binary-info.png"></a>  

We can see that the NX bit is set. This is the security feature we are defeating.
##### Identify sections:
<a href="/assets/img/2020-02-14-Fluff-x86/sections.png"><img src="/assets/img/2020-02-14-Fluff-x86/sections.png"></a>  

The .data section at 0x0804a028 will be the target to write the string "/bin/sh" to pass to the system() library function.
#### Search for ROP gadgets
In the search field we select "ROP gadgets", search in "All maps" and press "Search".

<a href="/assets/img/2020-02-14-Fluff-x86/rop-search.png"><img src="/assets/img/2020-02-14-Fluff-x86/rop-search.png"></a>  

Before we can write anything to memory, we need to identify the gadgets that will be best suited for the task.

<a href="/assets/img/2020-02-14-Fluff-x86/mov-edx-to-ecx-ptr.png"><img src="/assets/img/2020-02-14-Fluff-x86/mov-edx-to-ecx-ptr.png"></a>  

Searching through all mov instructions, the following gadget at 0x08048693 moves the contents of the EDX register to the location ECX points to.
```x86asm
0x08048693      mov dword [ecx], edx
0x08048695      pop ebp
0x08048696      pop ebx
0x08048697      xor byte [ecx], bl
0x08048699      ret
```
With the above gadget, the following will write bytes to the .data section:
1. Load the hexadecimal value of .data (0x0804a028) into the ECX register
2. Load bytes, that we wish to write, into the EDX register

###### Note: Padding values should be placed on the stack for the "pop" instructions on all gadgets before the final "ret" instruction

Approach to the defined steps above:
##### 1. Load the hexadecimal value of .data (0x0804a028) into the ECX register
Without a "pop ecx" or a simple "mov ecx, ???", other instructions must be used to load a value into ECX.

<a href="/assets/img/2020-02-14-Fluff-x86/xchg-edx-ecx.png"><img src="/assets/img/2020-02-14-Fluff-x86/xchg-edx-ecx.png"></a>
```x86asm
0x08048684      mov edi, 0xdeadbeef
0x08048689      xchg edx, ecx
0x0804868b      pop ebp
0x0804868c      mov edx, 0xdefaced0
0x08048691      ret
```
The xchg instruction at 0x08048689 will swap the values of the EDX and ECX registers.  
Searching for pop instructions returns very few options.

<a href="/assets/img/2020-02-14-Fluff-x86/search-pop.png"><img src="/assets/img/2020-02-14-Fluff-x86/search-pop.png"></a>

Searching for xor instructions returns very few options.

<a href="/assets/img/2020-02-14-Fluff-x86/search-xor.png"><img src="/assets/img/2020-02-14-Fluff-x86/search-xor.png"></a>

There is only one gadget that performs a xor on one register as both arguments.  
```x86asm
0x08048670      pop edi
0x08048671      xor edx, edx
0x08048673      pop esi
0x08048674      mov ebp, 0xcafebabe
0x08048679      ret
```
This is important because the EDX register will be zeroed out after the gadget at 0x08048671, which would allow another value to be copied into EDX.

<a href="/assets/img/2020-02-14-Fluff-x86/xor-edx-ebx.png"><img src="/assets/img/2020-02-14-Fluff-x86/xor-edx-ebx.png"></a>

The gadget at 0x0804867b performs the xor operation on EDX and EBX.
If a value is loaded into EBX and xor'd with EDX (if EDX is set to zero), EDX will contain the original value set in EBX before the operation.  
```x86asm
0x0804867a      pop esi
0x0804867b      xor edx, ebx
0x0804867d      pop ebp
0x0804867e      mov edi, 0xdeadbabe
0x08048683      ret
```
Searching for pop ebx returns many results.

<a href="/assets/img/2020-02-14-Fluff-x86/pop-ebx.png"><img src="/assets/img/2020-02-14-Fluff-x86/pop-ebx.png"></a>
```x86asm
0x08048713      add esp, 8
0x08048716      pop ebx
0x08048717      ret
```
The gadget at 0x08048716 will pop the next 4 bytes on the stack into EBX.

Combined, the mentioned gadgets will load a value into ECX with the following sequence:  
```x86asm
StepOne:
    pop ebx ; load value on stack into EBX
    ret
StepTwo:  
    xor edx, edx ; zero out the EDX register
    pop esi
    mov ebp, 0xcafebabe
    ret
StepThree:  
    xor edx, ebx ; the xor operation will exchange the contents of EBX into EDX
    pop ebp
    mov edi, 0xdeadbabe
    ret
StepFour:  
    xchg edx, ecx ; the xchg operation performs an exchange between the EDX and ECX registers respectively
    pop ebp
    mov edx, 0xdefaced0
    ret
```

##### 2. Load bytes, that we wish to write, into the EDX register
The previous sequence to write to ECX, uses the EDX register to transfer bytes.  
Writing to EDX will follow the same sequence without StepFour:
```x86asm
StepOne:
    pop ebx ; load value on stack into EBX
    ret
StepTwo:
    xor edx, edx ; zero out the EDX register
    pop esi
    mov ebp, 0xcafebabe
    ret
StepThree:
    xor edx, ebx ; the xor operation will exchange the contents of EBX into EDX
    pop ebp
    mov edi, 0xdeadbabe
    ret
```

#### Write the exploit
```go
package main

import (
    "log"
    "bufio"
    "os/exec"
    "fmt"
)

func main() {
}
```
